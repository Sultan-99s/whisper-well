# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Slot types

class SlotOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Slot create method"""
    id: _int
    booked: _bool
    created_at: datetime.datetime
    booking: 'BookingCreateNestedWithoutRelationsInput'


class SlotCreateInput(SlotOptionalCreateInput):
    """Required arguments to the Slot create method"""
    date: _str
    time_slot: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SlotOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Slot create method, without relations"""
    id: _int
    booked: _bool
    created_at: datetime.datetime


class SlotCreateWithoutRelationsInput(SlotOptionalCreateWithoutRelationsInput):
    """Required arguments to the Slot create method, without relations"""
    date: _str
    time_slot: _str

class SlotConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'SlotCreateWithoutRelationsInput'
    where: 'SlotWhereUniqueInput'

class SlotCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SlotCreateWithoutRelationsInput'
    connect: 'SlotWhereUniqueInput'
    connect_or_create: 'SlotConnectOrCreateWithoutRelationsInput'


class SlotCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SlotCreateWithoutRelationsInput', List['SlotCreateWithoutRelationsInput']]
    connect: Union['SlotWhereUniqueInput', List['SlotWhereUniqueInput']]
    connect_or_create: Union['SlotConnectOrCreateWithoutRelationsInput', List['SlotConnectOrCreateWithoutRelationsInput']]

_SlotWhereUnique_id_Input = TypedDict(
    '_SlotWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_SlotCompounddate_time_slotKeyInner = TypedDict(
    '_SlotCompounddate_time_slotKeyInner',
    {
        'date': '_str',
        'time_slot': '_str',
    },
    total=True
)

_SlotCompounddate_time_slotKey = TypedDict(
    '_SlotCompounddate_time_slotKey',
    {
        'date_time_slot': '_SlotCompounddate_time_slotKeyInner',
    },
    total=True
)

SlotWhereUniqueInput = Union[
    '_SlotWhereUnique_id_Input',
    '_SlotCompounddate_time_slotKey',
]


class SlotUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    date: _str
    time_slot: _str
    booked: _bool
    created_at: datetime.datetime
    booking: 'BookingUpdateOneWithoutRelationsInput'


class SlotUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    date: _str
    time_slot: _str
    booked: _bool
    created_at: datetime.datetime


class SlotUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SlotCreateWithoutRelationsInput']
    connect: List['SlotWhereUniqueInput']
    connect_or_create: List['SlotConnectOrCreateWithoutRelationsInput']
    set: List['SlotWhereUniqueInput']
    disconnect: List['SlotWhereUniqueInput']
    delete: List['SlotWhereUniqueInput']

    # TODO
    # update: List['SlotUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SlotUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SlotScalarWhereInput']
    # upsert: List['SlotUpserteWithWhereUniqueWithoutRelationsInput']


class SlotUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SlotCreateWithoutRelationsInput'
    connect: 'SlotWhereUniqueInput'
    connect_or_create: 'SlotConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SlotUpdateInput'
    # upsert: 'SlotUpsertWithoutRelationsInput'


class SlotUpsertInput(TypedDict):
    create: 'SlotCreateInput'
    update: 'SlotUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Slot_id_OrderByInput = TypedDict(
    '_Slot_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Slot_date_OrderByInput = TypedDict(
    '_Slot_date_OrderByInput',
    {
        'date': 'SortOrder',
    },
    total=True
)

_Slot_time_slot_OrderByInput = TypedDict(
    '_Slot_time_slot_OrderByInput',
    {
        'time_slot': 'SortOrder',
    },
    total=True
)

_Slot_booked_OrderByInput = TypedDict(
    '_Slot_booked_OrderByInput',
    {
        'booked': 'SortOrder',
    },
    total=True
)

_Slot_created_at_OrderByInput = TypedDict(
    '_Slot_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Slot_RelevanceInner = TypedDict(
    '_Slot_RelevanceInner',
    {
        'fields': 'List[SlotScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Slot_RelevanceOrderByInput = TypedDict(
    '_Slot_RelevanceOrderByInput',
    {
        '_relevance': '_Slot_RelevanceInner',
    },
    total=True
)

SlotOrderByInput = Union[
    '_Slot_id_OrderByInput',
    '_Slot_date_OrderByInput',
    '_Slot_time_slot_OrderByInput',
    '_Slot_booked_OrderByInput',
    '_Slot_created_at_OrderByInput',
    '_Slot_RelevanceOrderByInput',
]



# recursive Slot types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SlotRelationFilter = TypedDict(
    'SlotRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SlotListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SlotInclude(TypedDict, total=False):
    """Slot relational arguments"""
    booking: Union[bool, 'BookingArgsFromSlot']


    

class SlotIncludeFromSlot(TypedDict, total=False):
    """Relational arguments for Slot"""
    booking: Union[bool, 'BookingArgsFromSlotRecursive1']


class SlotIncludeFromSlotRecursive1(TypedDict, total=False):
    """Relational arguments for Slot"""
    booking: Union[bool, 'BookingArgsFromSlotRecursive2']


class SlotIncludeFromSlotRecursive2(TypedDict, total=False):
    """Relational arguments for Slot"""
    booking: Union[bool, 'BookingArgsFromSlotRecursive3']


class SlotIncludeFromSlotRecursive3(TypedDict, total=False):
    """Relational arguments for Slot"""
    booking: Union[bool, 'BookingArgsFromSlotRecursive4']


class SlotIncludeFromSlotRecursive4(TypedDict, total=False):
    """Relational arguments for Slot"""

    

class SlotArgsFromSlot(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'SlotIncludeFromSlotRecursive1'


class SlotArgsFromSlotRecursive1(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'SlotIncludeFromSlotRecursive2'


class SlotArgsFromSlotRecursive2(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'SlotIncludeFromSlotRecursive3'


class SlotArgsFromSlotRecursive3(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'SlotIncludeFromSlotRecursive4'


class SlotArgsFromSlotRecursive4(TypedDict, total=False):
    """Arguments for Slot"""
    
    

class FindManySlotArgsFromSlot(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive1'


class FindManySlotArgsFromSlotRecursive1(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive2'


class FindManySlotArgsFromSlotRecursive2(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive3'


class FindManySlotArgsFromSlotRecursive3(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive4'


class FindManySlotArgsFromSlotRecursive4(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    
    

class BookingIncludeFromSlot(TypedDict, total=False):
    """Relational arguments for Slot"""
    slot: Union[bool, 'SlotArgsFromSlotRecursive1']


class BookingIncludeFromSlotRecursive1(TypedDict, total=False):
    """Relational arguments for Slot"""
    slot: Union[bool, 'SlotArgsFromSlotRecursive2']


class BookingIncludeFromSlotRecursive2(TypedDict, total=False):
    """Relational arguments for Slot"""
    slot: Union[bool, 'SlotArgsFromSlotRecursive3']


class BookingIncludeFromSlotRecursive3(TypedDict, total=False):
    """Relational arguments for Slot"""
    slot: Union[bool, 'SlotArgsFromSlotRecursive4']


class BookingIncludeFromSlotRecursive4(TypedDict, total=False):
    """Relational arguments for Slot"""

    

class BookingArgsFromSlot(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'BookingIncludeFromBookingRecursive1'


class BookingArgsFromSlotRecursive1(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'BookingIncludeFromBookingRecursive2'


class BookingArgsFromSlotRecursive2(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'BookingIncludeFromBookingRecursive3'


class BookingArgsFromSlotRecursive3(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'BookingIncludeFromBookingRecursive4'


class BookingArgsFromSlotRecursive4(TypedDict, total=False):
    """Arguments for Slot"""
    
    

class FindManyBookingArgsFromSlot(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive1'


class FindManyBookingArgsFromSlotRecursive1(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive2'


class FindManyBookingArgsFromSlotRecursive2(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive3'


class FindManyBookingArgsFromSlotRecursive3(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive4'


class FindManyBookingArgsFromSlotRecursive4(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    
    

class UrgentRequestIncludeFromSlot(TypedDict, total=False):
    """Relational arguments for Slot"""


class UrgentRequestIncludeFromSlotRecursive1(TypedDict, total=False):
    """Relational arguments for Slot"""


class UrgentRequestIncludeFromSlotRecursive2(TypedDict, total=False):
    """Relational arguments for Slot"""


class UrgentRequestIncludeFromSlotRecursive3(TypedDict, total=False):
    """Relational arguments for Slot"""


class UrgentRequestIncludeFromSlotRecursive4(TypedDict, total=False):
    """Relational arguments for Slot"""

    

class UrgentRequestArgsFromSlot(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive1'


class UrgentRequestArgsFromSlotRecursive1(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive2'


class UrgentRequestArgsFromSlotRecursive2(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive3'


class UrgentRequestArgsFromSlotRecursive3(TypedDict, total=False):
    """Arguments for Slot"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive4'


class UrgentRequestArgsFromSlotRecursive4(TypedDict, total=False):
    """Arguments for Slot"""
    
    

class FindManyUrgentRequestArgsFromSlot(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive1'


class FindManyUrgentRequestArgsFromSlotRecursive1(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive2'


class FindManyUrgentRequestArgsFromSlotRecursive2(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive3'


class FindManyUrgentRequestArgsFromSlotRecursive3(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive4'


class FindManyUrgentRequestArgsFromSlotRecursive4(TypedDict, total=False):
    """Arguments for Slot"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    


FindManySlotArgs = FindManySlotArgsFromSlot
FindFirstSlotArgs = FindManySlotArgsFromSlot


    

class SlotWhereInput(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    date: Union[_str, 'types.StringFilter']
    time_slot: Union[_str, 'types.StringFilter']
    booked: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    booking: 'BookingRelationFilter'

    # should be noted that AND and NOT should be Union['SlotWhereInputRecursive1', List['SlotWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SlotWhereInputRecursive1']
    OR: List['SlotWhereInputRecursive1']
    NOT: List['SlotWhereInputRecursive1']


class SlotWhereInputRecursive1(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    date: Union[_str, 'types.StringFilter']
    time_slot: Union[_str, 'types.StringFilter']
    booked: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    booking: 'BookingRelationFilter'

    # should be noted that AND and NOT should be Union['SlotWhereInputRecursive2', List['SlotWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SlotWhereInputRecursive2']
    OR: List['SlotWhereInputRecursive2']
    NOT: List['SlotWhereInputRecursive2']


class SlotWhereInputRecursive2(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    date: Union[_str, 'types.StringFilter']
    time_slot: Union[_str, 'types.StringFilter']
    booked: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    booking: 'BookingRelationFilter'

    # should be noted that AND and NOT should be Union['SlotWhereInputRecursive3', List['SlotWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SlotWhereInputRecursive3']
    OR: List['SlotWhereInputRecursive3']
    NOT: List['SlotWhereInputRecursive3']


class SlotWhereInputRecursive3(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    date: Union[_str, 'types.StringFilter']
    time_slot: Union[_str, 'types.StringFilter']
    booked: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    booking: 'BookingRelationFilter'

    # should be noted that AND and NOT should be Union['SlotWhereInputRecursive4', List['SlotWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SlotWhereInputRecursive4']
    OR: List['SlotWhereInputRecursive4']
    NOT: List['SlotWhereInputRecursive4']


class SlotWhereInputRecursive4(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    date: Union[_str, 'types.StringFilter']
    time_slot: Union[_str, 'types.StringFilter']
    booked: Union[_bool, 'types.BooleanFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']
    booking: 'BookingRelationFilter'



# aggregate Slot types


    

class SlotScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    time_slot: Union[_str, 'types.StringWithAggregatesFilter']
    booked: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SlotScalarWhereWithAggregatesInputRecursive1']
    OR: List['SlotScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SlotScalarWhereWithAggregatesInputRecursive1']


class SlotScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    time_slot: Union[_str, 'types.StringWithAggregatesFilter']
    booked: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SlotScalarWhereWithAggregatesInputRecursive2']
    OR: List['SlotScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SlotScalarWhereWithAggregatesInputRecursive2']


class SlotScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    time_slot: Union[_str, 'types.StringWithAggregatesFilter']
    booked: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SlotScalarWhereWithAggregatesInputRecursive3']
    OR: List['SlotScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SlotScalarWhereWithAggregatesInputRecursive3']


class SlotScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    time_slot: Union[_str, 'types.StringWithAggregatesFilter']
    booked: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SlotScalarWhereWithAggregatesInputRecursive4']
    OR: List['SlotScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SlotScalarWhereWithAggregatesInputRecursive4']


class SlotScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Slot arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    date: Union[_str, 'types.StringWithAggregatesFilter']
    time_slot: Union[_str, 'types.StringWithAggregatesFilter']
    booked: Union[_bool, 'types.BooleanWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class SlotGroupByOutput(TypedDict, total=False):
    id: _int
    date: _str
    time_slot: _str
    booked: _bool
    created_at: datetime.datetime
    _sum: 'SlotSumAggregateOutput'
    _avg: 'SlotAvgAggregateOutput'
    _min: 'SlotMinAggregateOutput'
    _max: 'SlotMaxAggregateOutput'
    _count: 'SlotCountAggregateOutput'


class SlotAvgAggregateOutput(TypedDict, total=False):
    """Slot output for aggregating averages"""
    id: float


class SlotSumAggregateOutput(TypedDict, total=False):
    """Slot output for aggregating sums"""
    id: _int


class SlotScalarAggregateOutput(TypedDict, total=False):
    """Slot output including scalar fields"""
    id: _int
    date: _str
    time_slot: _str
    booked: _bool
    created_at: datetime.datetime


SlotMinAggregateOutput = SlotScalarAggregateOutput
SlotMaxAggregateOutput = SlotScalarAggregateOutput


class SlotMaxAggregateInput(TypedDict, total=False):
    """Slot input for aggregating by max"""
    id: bool
    date: bool
    time_slot: bool
    booked: bool
    created_at: bool


class SlotMinAggregateInput(TypedDict, total=False):
    """Slot input for aggregating by min"""
    id: bool
    date: bool
    time_slot: bool
    booked: bool
    created_at: bool


class SlotNumberAggregateInput(TypedDict, total=False):
    """Slot input for aggregating numbers"""
    id: bool


SlotAvgAggregateInput = SlotNumberAggregateInput
SlotSumAggregateInput = SlotNumberAggregateInput


SlotCountAggregateInput = TypedDict(
    'SlotCountAggregateInput',
    {
        'id': bool,
        'date': bool,
        'time_slot': bool,
        'booked': bool,
        'created_at': bool,
        '_all': bool,
    },
    total=False,
)

SlotCountAggregateOutput = TypedDict(
    'SlotCountAggregateOutput',
    {
        'id': int,
        'date': int,
        'time_slot': int,
        'booked': int,
        'created_at': int,
        '_all': int,
    },
    total=False,
)


SlotKeys = Literal[
    'id',
    'date',
    'time_slot',
    'booked',
    'created_at',
    'booking',
]
SlotScalarFieldKeys = Literal[
    'id',
    'date',
    'time_slot',
    'booked',
    'created_at',
]
SlotScalarFieldKeysT = TypeVar('SlotScalarFieldKeysT', bound=SlotScalarFieldKeys)

SlotRelationalFieldKeys = Literal[
        'booking',
    ]

# Booking types

class BookingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Booking create method"""
    id: _int
    slot: 'SlotCreateNestedWithoutRelationsInput'
    slotId: _int
    created_at: datetime.datetime


class BookingCreateInput(BookingOptionalCreateInput):
    """Required arguments to the Booking create method"""
    email: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BookingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Booking create method, without relations"""
    id: _int
    slotId: _int
    created_at: datetime.datetime


class BookingCreateWithoutRelationsInput(BookingOptionalCreateWithoutRelationsInput):
    """Required arguments to the Booking create method, without relations"""
    email: _str

class BookingConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BookingCreateWithoutRelationsInput'
    where: 'BookingWhereUniqueInput'

class BookingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BookingCreateWithoutRelationsInput'
    connect: 'BookingWhereUniqueInput'
    connect_or_create: 'BookingConnectOrCreateWithoutRelationsInput'


class BookingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BookingCreateWithoutRelationsInput', List['BookingCreateWithoutRelationsInput']]
    connect: Union['BookingWhereUniqueInput', List['BookingWhereUniqueInput']]
    connect_or_create: Union['BookingConnectOrCreateWithoutRelationsInput', List['BookingConnectOrCreateWithoutRelationsInput']]

_BookingWhereUnique_id_Input = TypedDict(
    '_BookingWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_BookingWhereUnique_slotId_Input = TypedDict(
    '_BookingWhereUnique_slotId_Input',
    {
        'slotId': '_int',
    },
    total=True
)

BookingWhereUniqueInput = Union[
    '_BookingWhereUnique_id_Input',
    '_BookingWhereUnique_slotId_Input',
]


class BookingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    email: _str
    slot: 'SlotUpdateOneWithoutRelationsInput'
    created_at: datetime.datetime


class BookingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    email: _str
    created_at: datetime.datetime


class BookingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BookingCreateWithoutRelationsInput']
    connect: List['BookingWhereUniqueInput']
    connect_or_create: List['BookingConnectOrCreateWithoutRelationsInput']
    set: List['BookingWhereUniqueInput']
    disconnect: List['BookingWhereUniqueInput']
    delete: List['BookingWhereUniqueInput']

    # TODO
    # update: List['BookingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BookingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BookingScalarWhereInput']
    # upsert: List['BookingUpserteWithWhereUniqueWithoutRelationsInput']


class BookingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BookingCreateWithoutRelationsInput'
    connect: 'BookingWhereUniqueInput'
    connect_or_create: 'BookingConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BookingUpdateInput'
    # upsert: 'BookingUpsertWithoutRelationsInput'


class BookingUpsertInput(TypedDict):
    create: 'BookingCreateInput'
    update: 'BookingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Booking_id_OrderByInput = TypedDict(
    '_Booking_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Booking_email_OrderByInput = TypedDict(
    '_Booking_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Booking_slotId_OrderByInput = TypedDict(
    '_Booking_slotId_OrderByInput',
    {
        'slotId': 'SortOrder',
    },
    total=True
)

_Booking_created_at_OrderByInput = TypedDict(
    '_Booking_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_Booking_RelevanceInner = TypedDict(
    '_Booking_RelevanceInner',
    {
        'fields': 'List[BookingScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Booking_RelevanceOrderByInput = TypedDict(
    '_Booking_RelevanceOrderByInput',
    {
        '_relevance': '_Booking_RelevanceInner',
    },
    total=True
)

BookingOrderByInput = Union[
    '_Booking_id_OrderByInput',
    '_Booking_email_OrderByInput',
    '_Booking_slotId_OrderByInput',
    '_Booking_created_at_OrderByInput',
    '_Booking_RelevanceOrderByInput',
]



# recursive Booking types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

BookingRelationFilter = TypedDict(
    'BookingRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class BookingListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class BookingInclude(TypedDict, total=False):
    """Booking relational arguments"""
    slot: Union[bool, 'SlotArgsFromBooking']


    

class SlotIncludeFromBooking(TypedDict, total=False):
    """Relational arguments for Booking"""
    booking: Union[bool, 'BookingArgsFromBookingRecursive1']


class SlotIncludeFromBookingRecursive1(TypedDict, total=False):
    """Relational arguments for Booking"""
    booking: Union[bool, 'BookingArgsFromBookingRecursive2']


class SlotIncludeFromBookingRecursive2(TypedDict, total=False):
    """Relational arguments for Booking"""
    booking: Union[bool, 'BookingArgsFromBookingRecursive3']


class SlotIncludeFromBookingRecursive3(TypedDict, total=False):
    """Relational arguments for Booking"""
    booking: Union[bool, 'BookingArgsFromBookingRecursive4']


class SlotIncludeFromBookingRecursive4(TypedDict, total=False):
    """Relational arguments for Booking"""

    

class SlotArgsFromBooking(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'SlotIncludeFromSlotRecursive1'


class SlotArgsFromBookingRecursive1(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'SlotIncludeFromSlotRecursive2'


class SlotArgsFromBookingRecursive2(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'SlotIncludeFromSlotRecursive3'


class SlotArgsFromBookingRecursive3(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'SlotIncludeFromSlotRecursive4'


class SlotArgsFromBookingRecursive4(TypedDict, total=False):
    """Arguments for Booking"""
    
    

class FindManySlotArgsFromBooking(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive1'


class FindManySlotArgsFromBookingRecursive1(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive2'


class FindManySlotArgsFromBookingRecursive2(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive3'


class FindManySlotArgsFromBookingRecursive3(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive4'


class FindManySlotArgsFromBookingRecursive4(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    
    

class BookingIncludeFromBooking(TypedDict, total=False):
    """Relational arguments for Booking"""
    slot: Union[bool, 'SlotArgsFromBookingRecursive1']


class BookingIncludeFromBookingRecursive1(TypedDict, total=False):
    """Relational arguments for Booking"""
    slot: Union[bool, 'SlotArgsFromBookingRecursive2']


class BookingIncludeFromBookingRecursive2(TypedDict, total=False):
    """Relational arguments for Booking"""
    slot: Union[bool, 'SlotArgsFromBookingRecursive3']


class BookingIncludeFromBookingRecursive3(TypedDict, total=False):
    """Relational arguments for Booking"""
    slot: Union[bool, 'SlotArgsFromBookingRecursive4']


class BookingIncludeFromBookingRecursive4(TypedDict, total=False):
    """Relational arguments for Booking"""

    

class BookingArgsFromBooking(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'BookingIncludeFromBookingRecursive1'


class BookingArgsFromBookingRecursive1(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'BookingIncludeFromBookingRecursive2'


class BookingArgsFromBookingRecursive2(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'BookingIncludeFromBookingRecursive3'


class BookingArgsFromBookingRecursive3(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'BookingIncludeFromBookingRecursive4'


class BookingArgsFromBookingRecursive4(TypedDict, total=False):
    """Arguments for Booking"""
    
    

class FindManyBookingArgsFromBooking(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive1'


class FindManyBookingArgsFromBookingRecursive1(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive2'


class FindManyBookingArgsFromBookingRecursive2(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive3'


class FindManyBookingArgsFromBookingRecursive3(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive4'


class FindManyBookingArgsFromBookingRecursive4(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    
    

class UrgentRequestIncludeFromBooking(TypedDict, total=False):
    """Relational arguments for Booking"""


class UrgentRequestIncludeFromBookingRecursive1(TypedDict, total=False):
    """Relational arguments for Booking"""


class UrgentRequestIncludeFromBookingRecursive2(TypedDict, total=False):
    """Relational arguments for Booking"""


class UrgentRequestIncludeFromBookingRecursive3(TypedDict, total=False):
    """Relational arguments for Booking"""


class UrgentRequestIncludeFromBookingRecursive4(TypedDict, total=False):
    """Relational arguments for Booking"""

    

class UrgentRequestArgsFromBooking(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive1'


class UrgentRequestArgsFromBookingRecursive1(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive2'


class UrgentRequestArgsFromBookingRecursive2(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive3'


class UrgentRequestArgsFromBookingRecursive3(TypedDict, total=False):
    """Arguments for Booking"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive4'


class UrgentRequestArgsFromBookingRecursive4(TypedDict, total=False):
    """Arguments for Booking"""
    
    

class FindManyUrgentRequestArgsFromBooking(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive1'


class FindManyUrgentRequestArgsFromBookingRecursive1(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive2'


class FindManyUrgentRequestArgsFromBookingRecursive2(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive3'


class FindManyUrgentRequestArgsFromBookingRecursive3(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive4'


class FindManyUrgentRequestArgsFromBookingRecursive4(TypedDict, total=False):
    """Arguments for Booking"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    


FindManyBookingArgs = FindManyBookingArgsFromBooking
FindFirstBookingArgs = FindManyBookingArgsFromBooking


    

class BookingWhereInput(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    slot: 'SlotRelationFilter'
    slotId: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BookingWhereInputRecursive1', List['BookingWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['BookingWhereInputRecursive1']
    OR: List['BookingWhereInputRecursive1']
    NOT: List['BookingWhereInputRecursive1']


class BookingWhereInputRecursive1(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    slot: 'SlotRelationFilter'
    slotId: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BookingWhereInputRecursive2', List['BookingWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['BookingWhereInputRecursive2']
    OR: List['BookingWhereInputRecursive2']
    NOT: List['BookingWhereInputRecursive2']


class BookingWhereInputRecursive2(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    slot: 'SlotRelationFilter'
    slotId: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BookingWhereInputRecursive3', List['BookingWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['BookingWhereInputRecursive3']
    OR: List['BookingWhereInputRecursive3']
    NOT: List['BookingWhereInputRecursive3']


class BookingWhereInputRecursive3(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    slot: 'SlotRelationFilter'
    slotId: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BookingWhereInputRecursive4', List['BookingWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['BookingWhereInputRecursive4']
    OR: List['BookingWhereInputRecursive4']
    NOT: List['BookingWhereInputRecursive4']


class BookingWhereInputRecursive4(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    slot: 'SlotRelationFilter'
    slotId: Union[_int, 'types.IntFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Booking types


    

class BookingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    slotId: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BookingScalarWhereWithAggregatesInputRecursive1']
    OR: List['BookingScalarWhereWithAggregatesInputRecursive1']
    NOT: List['BookingScalarWhereWithAggregatesInputRecursive1']


class BookingScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    slotId: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BookingScalarWhereWithAggregatesInputRecursive2']
    OR: List['BookingScalarWhereWithAggregatesInputRecursive2']
    NOT: List['BookingScalarWhereWithAggregatesInputRecursive2']


class BookingScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    slotId: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BookingScalarWhereWithAggregatesInputRecursive3']
    OR: List['BookingScalarWhereWithAggregatesInputRecursive3']
    NOT: List['BookingScalarWhereWithAggregatesInputRecursive3']


class BookingScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    slotId: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BookingScalarWhereWithAggregatesInputRecursive4']
    OR: List['BookingScalarWhereWithAggregatesInputRecursive4']
    NOT: List['BookingScalarWhereWithAggregatesInputRecursive4']


class BookingScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Booking arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    slotId: Union[_int, 'types.IntWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class BookingGroupByOutput(TypedDict, total=False):
    id: _int
    email: _str
    slotId: _int
    created_at: datetime.datetime
    _sum: 'BookingSumAggregateOutput'
    _avg: 'BookingAvgAggregateOutput'
    _min: 'BookingMinAggregateOutput'
    _max: 'BookingMaxAggregateOutput'
    _count: 'BookingCountAggregateOutput'


class BookingAvgAggregateOutput(TypedDict, total=False):
    """Booking output for aggregating averages"""
    id: float
    slotId: float


class BookingSumAggregateOutput(TypedDict, total=False):
    """Booking output for aggregating sums"""
    id: _int
    slotId: _int


class BookingScalarAggregateOutput(TypedDict, total=False):
    """Booking output including scalar fields"""
    id: _int
    email: _str
    slotId: _int
    created_at: datetime.datetime


BookingMinAggregateOutput = BookingScalarAggregateOutput
BookingMaxAggregateOutput = BookingScalarAggregateOutput


class BookingMaxAggregateInput(TypedDict, total=False):
    """Booking input for aggregating by max"""
    id: bool
    email: bool
    slotId: bool
    created_at: bool


class BookingMinAggregateInput(TypedDict, total=False):
    """Booking input for aggregating by min"""
    id: bool
    email: bool
    slotId: bool
    created_at: bool


class BookingNumberAggregateInput(TypedDict, total=False):
    """Booking input for aggregating numbers"""
    id: bool
    slotId: bool


BookingAvgAggregateInput = BookingNumberAggregateInput
BookingSumAggregateInput = BookingNumberAggregateInput


BookingCountAggregateInput = TypedDict(
    'BookingCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'slotId': bool,
        'created_at': bool,
        '_all': bool,
    },
    total=False,
)

BookingCountAggregateOutput = TypedDict(
    'BookingCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'slotId': int,
        'created_at': int,
        '_all': int,
    },
    total=False,
)


BookingKeys = Literal[
    'id',
    'email',
    'slot',
    'slotId',
    'created_at',
]
BookingScalarFieldKeys = Literal[
    'id',
    'email',
    'slotId',
    'created_at',
]
BookingScalarFieldKeysT = TypeVar('BookingScalarFieldKeysT', bound=BookingScalarFieldKeys)

BookingRelationalFieldKeys = Literal[
        'slot',
    ]

# UrgentRequest types

class UrgentRequestOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UrgentRequest create method"""
    id: _int
    status: _str
    created_at: datetime.datetime


class UrgentRequestCreateInput(UrgentRequestOptionalCreateInput):
    """Required arguments to the UrgentRequest create method"""
    email: _str
    message: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UrgentRequestOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UrgentRequest create method, without relations"""
    id: _int
    status: _str
    created_at: datetime.datetime


class UrgentRequestCreateWithoutRelationsInput(UrgentRequestOptionalCreateWithoutRelationsInput):
    """Required arguments to the UrgentRequest create method, without relations"""
    email: _str
    message: _str

class UrgentRequestConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UrgentRequestCreateWithoutRelationsInput'
    where: 'UrgentRequestWhereUniqueInput'

class UrgentRequestCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UrgentRequestCreateWithoutRelationsInput'
    connect: 'UrgentRequestWhereUniqueInput'
    connect_or_create: 'UrgentRequestConnectOrCreateWithoutRelationsInput'


class UrgentRequestCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UrgentRequestCreateWithoutRelationsInput', List['UrgentRequestCreateWithoutRelationsInput']]
    connect: Union['UrgentRequestWhereUniqueInput', List['UrgentRequestWhereUniqueInput']]
    connect_or_create: Union['UrgentRequestConnectOrCreateWithoutRelationsInput', List['UrgentRequestConnectOrCreateWithoutRelationsInput']]

_UrgentRequestWhereUnique_id_Input = TypedDict(
    '_UrgentRequestWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

UrgentRequestWhereUniqueInput = _UrgentRequestWhereUnique_id_Input


class UrgentRequestUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    email: _str
    message: _str
    status: _str
    created_at: datetime.datetime


class UrgentRequestUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    email: _str
    message: _str
    status: _str
    created_at: datetime.datetime


class UrgentRequestUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UrgentRequestCreateWithoutRelationsInput']
    connect: List['UrgentRequestWhereUniqueInput']
    connect_or_create: List['UrgentRequestConnectOrCreateWithoutRelationsInput']
    set: List['UrgentRequestWhereUniqueInput']
    disconnect: List['UrgentRequestWhereUniqueInput']
    delete: List['UrgentRequestWhereUniqueInput']

    # TODO
    # update: List['UrgentRequestUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UrgentRequestUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UrgentRequestScalarWhereInput']
    # upsert: List['UrgentRequestUpserteWithWhereUniqueWithoutRelationsInput']


class UrgentRequestUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UrgentRequestCreateWithoutRelationsInput'
    connect: 'UrgentRequestWhereUniqueInput'
    connect_or_create: 'UrgentRequestConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UrgentRequestUpdateInput'
    # upsert: 'UrgentRequestUpsertWithoutRelationsInput'


class UrgentRequestUpsertInput(TypedDict):
    create: 'UrgentRequestCreateInput'
    update: 'UrgentRequestUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UrgentRequest_id_OrderByInput = TypedDict(
    '_UrgentRequest_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UrgentRequest_email_OrderByInput = TypedDict(
    '_UrgentRequest_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_UrgentRequest_message_OrderByInput = TypedDict(
    '_UrgentRequest_message_OrderByInput',
    {
        'message': 'SortOrder',
    },
    total=True
)

_UrgentRequest_status_OrderByInput = TypedDict(
    '_UrgentRequest_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_UrgentRequest_created_at_OrderByInput = TypedDict(
    '_UrgentRequest_created_at_OrderByInput',
    {
        'created_at': 'SortOrder',
    },
    total=True
)

_UrgentRequest_RelevanceInner = TypedDict(
    '_UrgentRequest_RelevanceInner',
    {
        'fields': 'List[UrgentRequestScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_UrgentRequest_RelevanceOrderByInput = TypedDict(
    '_UrgentRequest_RelevanceOrderByInput',
    {
        '_relevance': '_UrgentRequest_RelevanceInner',
    },
    total=True
)

UrgentRequestOrderByInput = Union[
    '_UrgentRequest_id_OrderByInput',
    '_UrgentRequest_email_OrderByInput',
    '_UrgentRequest_message_OrderByInput',
    '_UrgentRequest_status_OrderByInput',
    '_UrgentRequest_created_at_OrderByInput',
    '_UrgentRequest_RelevanceOrderByInput',
]



# recursive UrgentRequest types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UrgentRequestRelationFilter = TypedDict(
    'UrgentRequestRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UrgentRequestListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UrgentRequestInclude(TypedDict, total=False):
    """UrgentRequest relational arguments"""


    

class SlotIncludeFromUrgentRequest(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    booking: Union[bool, 'BookingArgsFromUrgentRequestRecursive1']


class SlotIncludeFromUrgentRequestRecursive1(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    booking: Union[bool, 'BookingArgsFromUrgentRequestRecursive2']


class SlotIncludeFromUrgentRequestRecursive2(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    booking: Union[bool, 'BookingArgsFromUrgentRequestRecursive3']


class SlotIncludeFromUrgentRequestRecursive3(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    booking: Union[bool, 'BookingArgsFromUrgentRequestRecursive4']


class SlotIncludeFromUrgentRequestRecursive4(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""

    

class SlotArgsFromUrgentRequest(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'SlotIncludeFromSlotRecursive1'


class SlotArgsFromUrgentRequestRecursive1(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'SlotIncludeFromSlotRecursive2'


class SlotArgsFromUrgentRequestRecursive2(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'SlotIncludeFromSlotRecursive3'


class SlotArgsFromUrgentRequestRecursive3(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'SlotIncludeFromSlotRecursive4'


class SlotArgsFromUrgentRequestRecursive4(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    
    

class FindManySlotArgsFromUrgentRequest(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive1'


class FindManySlotArgsFromUrgentRequestRecursive1(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive2'


class FindManySlotArgsFromUrgentRequestRecursive2(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive3'


class FindManySlotArgsFromUrgentRequestRecursive3(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    include: 'SlotIncludeFromSlotRecursive4'


class FindManySlotArgsFromUrgentRequestRecursive4(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['SlotOrderByInput', List['SlotOrderByInput']]
    where: 'SlotWhereInput'
    cursor: 'SlotWhereUniqueInput'
    distinct: List['SlotScalarFieldKeys']
    
    

class BookingIncludeFromUrgentRequest(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    slot: Union[bool, 'SlotArgsFromUrgentRequestRecursive1']


class BookingIncludeFromUrgentRequestRecursive1(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    slot: Union[bool, 'SlotArgsFromUrgentRequestRecursive2']


class BookingIncludeFromUrgentRequestRecursive2(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    slot: Union[bool, 'SlotArgsFromUrgentRequestRecursive3']


class BookingIncludeFromUrgentRequestRecursive3(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""
    slot: Union[bool, 'SlotArgsFromUrgentRequestRecursive4']


class BookingIncludeFromUrgentRequestRecursive4(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""

    

class BookingArgsFromUrgentRequest(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'BookingIncludeFromBookingRecursive1'


class BookingArgsFromUrgentRequestRecursive1(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'BookingIncludeFromBookingRecursive2'


class BookingArgsFromUrgentRequestRecursive2(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'BookingIncludeFromBookingRecursive3'


class BookingArgsFromUrgentRequestRecursive3(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'BookingIncludeFromBookingRecursive4'


class BookingArgsFromUrgentRequestRecursive4(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    
    

class FindManyBookingArgsFromUrgentRequest(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive1'


class FindManyBookingArgsFromUrgentRequestRecursive1(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive2'


class FindManyBookingArgsFromUrgentRequestRecursive2(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive3'


class FindManyBookingArgsFromUrgentRequestRecursive3(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    include: 'BookingIncludeFromBookingRecursive4'


class FindManyBookingArgsFromUrgentRequestRecursive4(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['BookingOrderByInput', List['BookingOrderByInput']]
    where: 'BookingWhereInput'
    cursor: 'BookingWhereUniqueInput'
    distinct: List['BookingScalarFieldKeys']
    
    

class UrgentRequestIncludeFromUrgentRequest(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""


class UrgentRequestIncludeFromUrgentRequestRecursive1(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""


class UrgentRequestIncludeFromUrgentRequestRecursive2(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""


class UrgentRequestIncludeFromUrgentRequestRecursive3(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""


class UrgentRequestIncludeFromUrgentRequestRecursive4(TypedDict, total=False):
    """Relational arguments for UrgentRequest"""

    

class UrgentRequestArgsFromUrgentRequest(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive1'


class UrgentRequestArgsFromUrgentRequestRecursive1(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive2'


class UrgentRequestArgsFromUrgentRequestRecursive2(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive3'


class UrgentRequestArgsFromUrgentRequestRecursive3(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive4'


class UrgentRequestArgsFromUrgentRequestRecursive4(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    
    

class FindManyUrgentRequestArgsFromUrgentRequest(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive1'


class FindManyUrgentRequestArgsFromUrgentRequestRecursive1(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive2'


class FindManyUrgentRequestArgsFromUrgentRequestRecursive2(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive3'


class FindManyUrgentRequestArgsFromUrgentRequestRecursive3(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    include: 'UrgentRequestIncludeFromUrgentRequestRecursive4'


class FindManyUrgentRequestArgsFromUrgentRequestRecursive4(TypedDict, total=False):
    """Arguments for UrgentRequest"""
    take: int
    skip: int
    order_by: Union['UrgentRequestOrderByInput', List['UrgentRequestOrderByInput']]
    where: 'UrgentRequestWhereInput'
    cursor: 'UrgentRequestWhereUniqueInput'
    distinct: List['UrgentRequestScalarFieldKeys']
    


FindManyUrgentRequestArgs = FindManyUrgentRequestArgsFromUrgentRequest
FindFirstUrgentRequestArgs = FindManyUrgentRequestArgsFromUrgentRequest


    

class UrgentRequestWhereInput(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UrgentRequestWhereInputRecursive1', List['UrgentRequestWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UrgentRequestWhereInputRecursive1']
    OR: List['UrgentRequestWhereInputRecursive1']
    NOT: List['UrgentRequestWhereInputRecursive1']


class UrgentRequestWhereInputRecursive1(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UrgentRequestWhereInputRecursive2', List['UrgentRequestWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UrgentRequestWhereInputRecursive2']
    OR: List['UrgentRequestWhereInputRecursive2']
    NOT: List['UrgentRequestWhereInputRecursive2']


class UrgentRequestWhereInputRecursive2(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UrgentRequestWhereInputRecursive3', List['UrgentRequestWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UrgentRequestWhereInputRecursive3']
    OR: List['UrgentRequestWhereInputRecursive3']
    NOT: List['UrgentRequestWhereInputRecursive3']


class UrgentRequestWhereInputRecursive3(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UrgentRequestWhereInputRecursive4', List['UrgentRequestWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UrgentRequestWhereInputRecursive4']
    OR: List['UrgentRequestWhereInputRecursive4']
    NOT: List['UrgentRequestWhereInputRecursive4']


class UrgentRequestWhereInputRecursive4(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    email: Union[_str, 'types.StringFilter']
    message: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate UrgentRequest types


    

class UrgentRequestScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UrgentRequestScalarWhereWithAggregatesInputRecursive1']
    OR: List['UrgentRequestScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UrgentRequestScalarWhereWithAggregatesInputRecursive1']


class UrgentRequestScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UrgentRequestScalarWhereWithAggregatesInputRecursive2']
    OR: List['UrgentRequestScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UrgentRequestScalarWhereWithAggregatesInputRecursive2']


class UrgentRequestScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UrgentRequestScalarWhereWithAggregatesInputRecursive3']
    OR: List['UrgentRequestScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UrgentRequestScalarWhereWithAggregatesInputRecursive3']


class UrgentRequestScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UrgentRequestScalarWhereWithAggregatesInputRecursive4']
    OR: List['UrgentRequestScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UrgentRequestScalarWhereWithAggregatesInputRecursive4']


class UrgentRequestScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """UrgentRequest arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    message: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    created_at: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class UrgentRequestGroupByOutput(TypedDict, total=False):
    id: _int
    email: _str
    message: _str
    status: _str
    created_at: datetime.datetime
    _sum: 'UrgentRequestSumAggregateOutput'
    _avg: 'UrgentRequestAvgAggregateOutput'
    _min: 'UrgentRequestMinAggregateOutput'
    _max: 'UrgentRequestMaxAggregateOutput'
    _count: 'UrgentRequestCountAggregateOutput'


class UrgentRequestAvgAggregateOutput(TypedDict, total=False):
    """UrgentRequest output for aggregating averages"""
    id: float


class UrgentRequestSumAggregateOutput(TypedDict, total=False):
    """UrgentRequest output for aggregating sums"""
    id: _int


class UrgentRequestScalarAggregateOutput(TypedDict, total=False):
    """UrgentRequest output including scalar fields"""
    id: _int
    email: _str
    message: _str
    status: _str
    created_at: datetime.datetime


UrgentRequestMinAggregateOutput = UrgentRequestScalarAggregateOutput
UrgentRequestMaxAggregateOutput = UrgentRequestScalarAggregateOutput


class UrgentRequestMaxAggregateInput(TypedDict, total=False):
    """UrgentRequest input for aggregating by max"""
    id: bool
    email: bool
    message: bool
    status: bool
    created_at: bool


class UrgentRequestMinAggregateInput(TypedDict, total=False):
    """UrgentRequest input for aggregating by min"""
    id: bool
    email: bool
    message: bool
    status: bool
    created_at: bool


class UrgentRequestNumberAggregateInput(TypedDict, total=False):
    """UrgentRequest input for aggregating numbers"""
    id: bool


UrgentRequestAvgAggregateInput = UrgentRequestNumberAggregateInput
UrgentRequestSumAggregateInput = UrgentRequestNumberAggregateInput


UrgentRequestCountAggregateInput = TypedDict(
    'UrgentRequestCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'message': bool,
        'status': bool,
        'created_at': bool,
        '_all': bool,
    },
    total=False,
)

UrgentRequestCountAggregateOutput = TypedDict(
    'UrgentRequestCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'message': int,
        'status': int,
        'created_at': int,
        '_all': int,
    },
    total=False,
)


UrgentRequestKeys = Literal[
    'id',
    'email',
    'message',
    'status',
    'created_at',
]
UrgentRequestScalarFieldKeys = Literal[
    'id',
    'email',
    'message',
    'status',
    'created_at',
]
UrgentRequestScalarFieldKeysT = TypeVar('UrgentRequestScalarFieldKeysT', bound=UrgentRequestScalarFieldKeys)

UrgentRequestRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields